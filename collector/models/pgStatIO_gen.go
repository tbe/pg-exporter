/*generated by binding gen*/
package models

import (
	"github.com/prometheus/client_golang/prometheus"
)

type PgStatIOSlice []PgStatIO

func (r PgStatIOSlice) ToMetrics(namespace string, subsystem string, ch chan<- prometheus.Metric, labelsKV ...string) error {
	for _, row := range []PgStatIO(r) {
		if err := row.ToMetrics(namespace, subsystem, ch, labelsKV...); err != nil {
			return err
		}
	}
	return nil
}

func (r *PgStatIO) ToMetrics(namespace string, subsystem string, ch chan<- prometheus.Metric, labelsKV ...string) error {
	labels := newLabels(labelsKV...)
	// labels
	labels["backend_type"] = r.BackendType
	labels["object"] = r.Object
	labels["context"] = r.Context

	// optional labels

	// metrics
	// reads_total (CounterValue)
	readsTotal := float64(r.Reads)
	ch <- prometheus.MustNewConstMetric(
		prometheus.NewDesc(
			prometheus.BuildFQName(namespace, subsystem, `reads_total`), `Number of read operations, each of the size specified in op_bytes`, nil, labels,
		), prometheus.CounterValue, readsTotal,
	)

	// read_time_total (CounterValue)

	ch <- prometheus.MustNewConstMetric(
		prometheus.NewDesc(
			prometheus.BuildFQName(namespace, subsystem, `read_time_total`), `Time spent in read operations in milliseconds`, nil, labels,
		), prometheus.CounterValue, r.ReadTime,
	)

	// writes_total (CounterValue)
	writesTotal := float64(r.Writes)
	ch <- prometheus.MustNewConstMetric(
		prometheus.NewDesc(
			prometheus.BuildFQName(namespace, subsystem, `writes_total`), `Number of write operations, each of the size specified in op_bytes`, nil, labels,
		), prometheus.CounterValue, writesTotal,
	)

	// write_time_total (CounterValue)

	ch <- prometheus.MustNewConstMetric(
		prometheus.NewDesc(
			prometheus.BuildFQName(namespace, subsystem, `write_time_total`), `Time spent in write operations in milliseconds`, nil, labels,
		), prometheus.CounterValue, r.WriteTime,
	)

	// writebacks_total (CounterValue)
	writebacksTotal := float64(r.Writebacks)
	ch <- prometheus.MustNewConstMetric(
		prometheus.NewDesc(
			prometheus.BuildFQName(namespace, subsystem, `writebacks_total`), `Number of units of size op_bytes which the process requested the kernel write out to permanent storage`, nil, labels,
		), prometheus.CounterValue, writebacksTotal,
	)

	// writeback_time_total (CounterValue)

	ch <- prometheus.MustNewConstMetric(
		prometheus.NewDesc(
			prometheus.BuildFQName(namespace, subsystem, `writeback_time_total`), `Time spent in writeback operations in milliseconds`, nil, labels,
		), prometheus.CounterValue, r.WritebackTime,
	)

	// extends_total (CounterValue)
	extendsTotal := float64(r.Extends)
	ch <- prometheus.MustNewConstMetric(
		prometheus.NewDesc(
			prometheus.BuildFQName(namespace, subsystem, `extends_total`), `Number of relation extend operations, each of the size specified in op_bytes`, nil, labels,
		), prometheus.CounterValue, extendsTotal,
	)

	// extend_time_total (CounterValue)

	ch <- prometheus.MustNewConstMetric(
		prometheus.NewDesc(
			prometheus.BuildFQName(namespace, subsystem, `extend_time_total`), `Time spent in extend operations in milliseconds`, nil, labels,
		), prometheus.CounterValue, r.ExtendTime,
	)

	// op_bytes (CounterValue)
	opBytes := float64(r.OPBytes)
	ch <- prometheus.MustNewConstMetric(
		prometheus.NewDesc(
			prometheus.BuildFQName(namespace, subsystem, `op_bytes`), `The number of bytes per unit of I/O read, written, or extended`, nil, labels,
		), prometheus.CounterValue, opBytes,
	)

	// hits_total (CounterValue)
	hitsTotal := float64(r.Hits)
	ch <- prometheus.MustNewConstMetric(
		prometheus.NewDesc(
			prometheus.BuildFQName(namespace, subsystem, `hits_total`), `The number of times a desired block was found in a shared buffer`, nil, labels,
		), prometheus.CounterValue, hitsTotal,
	)

	// evictions_total (CounterValue)
	evictionsTotal := float64(r.Evictions)
	ch <- prometheus.MustNewConstMetric(
		prometheus.NewDesc(
			prometheus.BuildFQName(namespace, subsystem, `evictions_total`), `Number of times a block has been written out from a shared or local buffer in order to make it available for another use`, nil, labels,
		), prometheus.CounterValue, evictionsTotal,
	)

	// reuses_total (CounterValue)
	reusesTotal := float64(r.Reuses)
	ch <- prometheus.MustNewConstMetric(
		prometheus.NewDesc(
			prometheus.BuildFQName(namespace, subsystem, `reuses_total`), `The number of times an existing buffer in a size-limited ring buffer outside of shared buffers was reused as part of an I/O operation in the bulkread, bulkwrite, or vacuum contexts`, nil, labels,
		), prometheus.CounterValue, reusesTotal,
	)

	// fsyncs_total (CounterValue)
	fsyncsTotal := float64(r.Fsyncs)
	ch <- prometheus.MustNewConstMetric(
		prometheus.NewDesc(
			prometheus.BuildFQName(namespace, subsystem, `fsyncs_total`), `Number of fsync calls. These are only tracked in context normal`, nil, labels,
		), prometheus.CounterValue, fsyncsTotal,
	)

	// fsync_time_total (CounterValue)

	ch <- prometheus.MustNewConstMetric(
		prometheus.NewDesc(
			prometheus.BuildFQName(namespace, subsystem, `fsync_time_total`), `Time spent in fsync operations calls in milliseconds`, nil, labels,
		), prometheus.CounterValue, r.FsyncTime,
	)

	// stats_reset_seconds (CounterValue)
	var statsResetSeconds float64
	if r.StatsReset.IsZero() {
		statsResetSeconds = float64(0)
	} else {
		statsResetSeconds = float64(r.StatsReset.Unix())
	}
	ch <- prometheus.MustNewConstMetric(
		prometheus.NewDesc(
			prometheus.BuildFQName(namespace, subsystem, `stats_reset_seconds`), `Time at which these statistics were last reset`, nil, labels,
		), prometheus.CounterValue, statsResetSeconds,
	)

	// optional metrics

	return nil
}
