/*generated by binding gen*/
package models

import (
	"strconv"

	"github.com/prometheus/client_golang/prometheus"
)

type PgStatSubscriptionStatsSlice []PgStatSubscriptionStats

func (r PgStatSubscriptionStatsSlice) ToMetrics(namespace string, subsystem string, ch chan<- prometheus.Metric, labelsKV ...string) error {
	for _, row := range []PgStatSubscriptionStats(r) {
		if err := row.ToMetrics(namespace, subsystem, ch, labelsKV...); err != nil {
			return err
		}
	}
	return nil
}

func (r *PgStatSubscriptionStats) ToMetrics(namespace string, subsystem string, ch chan<- prometheus.Metric, labelsKV ...string) error {
	labels := newLabels(labelsKV...)
	// labels
	labels["subscription_id"] = strconv.FormatInt(r.SubID, 10)
	labels["subscription"] = r.Subname

	// optional labels

	// metrics
	// apply_error_count (CounterValue)
	applyErrorCount := float64(r.ApplyErrorCount)
	ch <- prometheus.MustNewConstMetric(
		prometheus.NewDesc(
			prometheus.BuildFQName(namespace, subsystem, `apply_error_count`), `Number of errors that have occurred while applying changes`, nil, labels,
		), prometheus.CounterValue, applyErrorCount,
	)

	// sync_error_count (CounterValue)
	syncErrorCount := float64(r.SyncErrorCount)
	ch <- prometheus.MustNewConstMetric(
		prometheus.NewDesc(
			prometheus.BuildFQName(namespace, subsystem, `sync_error_count`), `Number of times an error occurred during the initial table synchronization`, nil, labels,
		), prometheus.CounterValue, syncErrorCount,
	)

	// stats_reset (CounterValue)
	var statsReset float64
	if r.StatsReset.IsZero() {
		statsReset = float64(0)
	} else {
		statsReset = float64(r.StatsReset.Unix())
	}
	ch <- prometheus.MustNewConstMetric(
		prometheus.NewDesc(
			prometheus.BuildFQName(namespace, subsystem, `stats_reset`), `Time at which these statistics were last reset`, nil, labels,
		), prometheus.CounterValue, statsReset,
	)

	// optional metrics

	return nil
}
